package gdpr

import (
	"github.com/prebid/go-gdpr/api"
	"github.com/prebid/go-gdpr/consentconstants"
	tcf2 "github.com/prebid/go-gdpr/vendorconsent/tcf2"
	"github.com/prebid/prebid-server/openrtb_ext"
)

// PurposeEnforcer represents the enforcement strategy for determining if legal basis is achieved for a purpose
type PurposeEnforcer interface {
	LegalBasis(vendorInfo VendorInfo, bidder openrtb_ext.BidderName, consent tcf2.ConsentMetadata) bool
}

// PurposeEnforcerBuilder generates an instance of PurposeEnforcer for a given purpose and bidder
type PurposeEnforcerBuilder func(p consentconstants.Purpose, bidder openrtb_ext.BidderName) PurposeEnforcer

type BidderInfo struct {
	bidderCoreName openrtb_ext.BidderName
	bidder         openrtb_ext.BidderName
}
type VendorInfo struct {
	vendorID uint16
	vendor   api.Vendor
}

const (
	TCF2BasicEnforcement string = "basic"
	TCF2FullEnforcement  string = "full"
)

// PurposeEnforcers holds the full and basic enforcers for a purpose
type PurposeEnforcers struct {
	Full  PurposeEnforcer
	Basic PurposeEnforcer
}

// NewPurposeEnforcerBuilder creates a new instance of PurposeEnforcerBuilder. This function uses
// closures with state so that any enforcer generated by the returned builder may be cached and
// reused within a request context
func NewPurposeEnforcerBuilder(cfg TCF2ConfigReader) PurposeEnforcerBuilder {
	cachedEnforcers := make([]PurposeEnforcers, 10)

	return func(purpose consentconstants.Purpose, bidder openrtb_ext.BidderName) PurposeEnforcer {	
		basicEnforcementVendor := cfg.BasicEnforcementVendor(bidder)
		if purpose == consentconstants.Purpose(1) {
			basicEnforcementVendor = false
		}
	
		enforceAlgo := cfg.PurposeEnforcementAlgo(purpose)
		downgraded := isDowngraded(enforceAlgo, basicEnforcementVendor)

		if enforceAlgo == TCF2BasicEnforcement || downgraded {
			if cachedEnforcers[purpose].Basic != nil {
				return cachedEnforcers[purpose].Basic
			}
		} else {
			if cachedEnforcers[purpose].Full != nil {
				return cachedEnforcers[purpose].Full
			}
		}

		purposeCfg := purposeConfig{
			PurposeID:                  purpose,
			EnforceAlgo:                enforceAlgo,
			EnforcePurpose:             cfg.PurposeEnforced(purpose),
			EnforceVendors:             cfg.PurposeEnforcingVendors(purpose),
			VendorExceptionMap:         cfg.PurposeVendorExceptions(purpose),
			BasicEnforcementVendorsMap: cfg.BasicEnforcementVendors(),
		}

		enforcer := NewPurposeEnforcer(purposeCfg, downgraded)
		if _, ok := enforcer.(*FullEnforcement); ok {
			cachedEnforcers[purpose].Full = enforcer
		} else {
			cachedEnforcers[purpose].Basic = enforcer
		}
	
		return enforcer
	}
}

// isDowngraded determines if the enforcement algorithm used to determine legal basis for a
// purpose should be downgraded from full enforcement to basic
func isDowngraded(enforceAlgo string, basicEnforcementVendor bool/*, haveGVL bool*/) bool {
	if enforceAlgo == TCF2FullEnforcement && basicEnforcementVendor {
		return true
	}
	return false
}

// NewPurposeEnforcer returns either a basic or full enforcer for the specified purpose
// based on the purpose config and whether the algorithm was downgraded
func NewPurposeEnforcer(cfg purposeConfig, downgraded bool) PurposeEnforcer {
	if cfg.EnforceAlgo == TCF2BasicEnforcement {
		return NewBasicEnforcement(cfg)
	} else if downgraded {
		return NewBasicEnforcement(cfg)
	}
	return NewFullEnforcement(cfg)
}
